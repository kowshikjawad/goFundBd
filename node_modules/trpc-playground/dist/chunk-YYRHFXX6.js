// src/config.ts
import lodash from "lodash";

// html-version:./html-version
var version = "1.0.4";

// src/config.ts
var defineConfig = (config) => config;
var getDefaultConfig = () => defineConfig({
  resolveTypes: zodResolveTypes,
  polling: {
    enable: true,
    interval: 4e3
  },
  renderOptions: {
    cdnUrl: "//cdn.jsdelivr.net/npm",
    version
  },
  request: {
    globalHeaders: {},
    superjson: false
  },
  server: {
    serveHtml: true
  }
});
var resolveConfig = (config) => {
  const resolvedConfig = lodash.merge({}, getDefaultConfig(), config);
  const resolvedVersion = config?.renderOptions?.version === null ? null : resolvedConfig.renderOptions.version;
  return {
    ...resolvedConfig,
    renderOptions: {
      ...resolvedConfig.renderOptions,
      version: resolvedVersion
    }
  };
};

// src/zod-resolve-types.ts
import lodash2 from "lodash";
import { z as z2 } from "zod";

// src/get-default-input.ts
import {
  z,
  ZodFirstPartyTypeKind
} from "zod";
import { createTypeAlias, printNode, zodToTs } from "zod-to-ts";
var getProcedureSchemas = (procedures) => {
  const procedureSchemas = { queries: {}, mutations: {} };
  const procedureTypes = { queries: {}, mutations: {} };
  Object.entries(procedures).filter(([, { _def }]) => _def.query || _def.mutation).forEach(([procedureName, procedure]) => {
    const inputParser = getInputFromInputParsers(procedure._def.inputs);
    if (typeof inputParser === "function") {
      return z.any();
    }
    const defaultInputValue = inputParser ? getDefaultForDef(inputParser._def) : "";
    let procedureType = "";
    let docsType = "";
    if (inputParser) {
      const { node } = zodToTs(inputParser);
      procedureType = `input: ${printNode(node)}`;
      docsType = printNode(createTypeAlias(node, "input", inputParser.description));
    }
    const procedureDefaults = {
      inputLength: defaultInputValue.length,
      value: `await trpc.${procedureName}.${procedure._def.query ? "query" : "mutate"}(${defaultInputValue})`
    };
    const procedureObject = procedure._def.query ? procedureSchemas.queries : procedureSchemas.mutations;
    const typeProcedureObject = procedure._def.query ? procedureTypes.queries : procedureTypes.mutations;
    procedureObject[procedureName] = { default: procedureDefaults, type: docsType };
    typeProcedureObject[procedureName] = procedureType;
  });
  return { schemas: procedureSchemas, types: procedureTypes };
};
var getDefaultForDef = (def) => {
  if (!def)
    return "";
  switch (def.typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return defaultString();
    case ZodFirstPartyTypeKind.ZodDate:
      return defaultDate();
    case ZodFirstPartyTypeKind.ZodNumber:
      return defaultNumber();
    case ZodFirstPartyTypeKind.ZodBigInt:
      return defaultBigInt();
    case ZodFirstPartyTypeKind.ZodBoolean:
      return defaultBoolean();
    case ZodFirstPartyTypeKind.ZodUndefined:
      return defaultUndefined();
    case ZodFirstPartyTypeKind.ZodNull:
      return defaultNull();
    case ZodFirstPartyTypeKind.ZodObject:
      return defaultObject(def);
    case ZodFirstPartyTypeKind.ZodArray:
      return defaultArray(def);
    case ZodFirstPartyTypeKind.ZodTuple:
      return defaultTuple(def);
    case ZodFirstPartyTypeKind.ZodRecord:
      return defaultRecord(def);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return defaultLiteral(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return defaultNullable(def);
    case ZodFirstPartyTypeKind.ZodOptional:
      return defaultOptional(def);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return defaultIntersection(def);
    case ZodFirstPartyTypeKind.ZodEnum:
      return defaultEnum(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return defaultNativeEnum(def);
    case ZodFirstPartyTypeKind.ZodMap:
      return defaultMap(def);
    case ZodFirstPartyTypeKind.ZodSet:
      return defaultSet(def);
    case ZodFirstPartyTypeKind.ZodPromise:
      return defaultPromise(def);
    case ZodFirstPartyTypeKind.ZodNaN:
      return "NaN";
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
    case ZodFirstPartyTypeKind.ZodUnion:
      return defaultUnion(def);
    default:
      return "";
  }
};
var defaultString = () => {
  return `""`;
};
var defaultDate = () => {
  return `new Date()`;
};
var defaultNumber = () => {
  return `0`;
};
var defaultBigInt = () => {
  return `BigInt(0)`;
};
var defaultBoolean = () => {
  return `false`;
};
var defaultUndefined = () => {
  return `undefined`;
};
var defaultNull = () => {
  return `null`;
};
var defaultObject = (def) => {
  let ret = `{ `;
  const entries = Object.entries(def.shape());
  entries.forEach(([name, propDef], idx) => {
    ret += `${name}: ${getDefaultForDef(propDef._def)}`;
    if (idx !== entries.length - 1)
      ret += `, `;
    else
      ret += ` `;
  });
  ret += `}`;
  return ret;
};
var defaultArray = (def) => {
  return `[${getDefaultForDef(def.type._def)}]`;
};
var defaultTuple = (def) => {
  let ret = `[`;
  for (let i = 0; i < def.items.length; i++) {
    const item = def.items[i];
    ret += `${getDefaultForDef(item._def)}`;
    if (i !== def.items.length - 1)
      ret += ``;
  }
  return ret;
};
var defaultRecord = (_def) => {
  return `{ ${getDefaultForDef(_def.keyType._def)}: ${getDefaultForDef(_def.valueType._def)} }`;
};
var defaultLiteral = (def) => {
  return typeof def.value === "string" ? `"${def.value}"` : `${def.value}`;
};
var defaultNullable = (def) => {
  return getDefaultForDef(def.innerType._def);
};
var defaultOptional = (def) => {
  return getDefaultForDef(def.innerType._def) ?? `undefined`;
};
var defaultEnum = (def) => {
  return `"${def.values[0]}"`;
};
var defaultUnion = (def) => {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.length === 0)
    return "";
  return getDefaultForDef(options[0]._def);
};
var defaultIntersection = (def) => {
  return getDefaultForDef(def.right._def);
};
var defaultNativeEnum = (def) => {
  const val = Object.values(def.values)[Object.values(def.values).length - 1];
  if (val) {
    return typeof val === "string" ? `"${val}"` : `${val}`;
  }
  return "";
};
var defaultMap = (_def) => {
  return `new Map([[${getDefaultForDef(_def.keyType._def)}, ${getDefaultForDef(_def.valueType._def)}]])`;
};
var defaultSet = (_def) => {
  return `new Set([${getDefaultForDef(_def.valueType._def)}])`;
};
var defaultPromise = (def) => {
  return `Promise.resolve(${getDefaultForDef(def.type._def)})`;
};

// src/zod-resolve-types.ts
var buildTrpcTsType = (router, procedureTypes) => {
  const procedures = router._def.procedures;
  const procedureObject = {};
  Object.entries(procedures).filter(([, { _def }]) => _def.query || _def.mutation).forEach(([name, procedure]) => {
    let procedureTypeDef = "";
    const inputType = procedureTypes.mutations[name] || procedureTypes.queries[name] || "";
    if (procedure._def?.query)
      procedureTypeDef += `query: (${inputType}) => void,`;
    else if (procedure._def?.mutation)
      procedureTypeDef += `mutate: (${inputType}) => void,`;
    lodash2.set(procedureObject, name, `{${procedureTypeDef}}`);
  });
  const buildNestedTrpcObject = (obj) => {
    return Object.entries(obj).map(([name, value]) => {
      if (typeof value === "string")
        return `'${name}': ${value}`;
      return `'${name}': {${buildNestedTrpcObject(value)}}`;
    }).join(",");
  };
  return `type Trpc = {${buildNestedTrpcObject(procedureObject)}}
declare var trpc: Trpc;`;
};
var zodResolveTypes = async (router) => {
  const { schemas, types } = getProcedureSchemas(router._def.procedures);
  return {
    tsTypes: buildTrpcTsType(router, types),
    ...schemas
  };
};
var getInputFromInputParsers = (inputs) => {
  if (inputs.length === 0)
    return null;
  if (inputs.length === 1)
    return inputs[0];
  const mergedObj = inputs.reduce((mergedObj2, inputParser) => {
    return mergedObj2.merge(inputParser);
  }, z2.object({}));
  return mergedObj;
};

export {
  resolveConfig,
  zodResolveTypes,
  getInputFromInputParsers
};
