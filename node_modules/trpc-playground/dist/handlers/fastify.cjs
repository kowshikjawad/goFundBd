"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/handlers/fastify.ts
var fastify_exports = {};
__export(fastify_exports, {
  getFastifyPlugin: () => getFastifyPlugin
});
module.exports = __toCommonJS(fastify_exports);
var import_fastify = require("uttp/adapters/fastify");

// src/handler.ts
var import_html = require("@trpc-playground/html");
var import_uttp = require("uttp");

// src/config.ts
var import_lodash2 = __toESM(require("lodash"), 1);

// src/zod-resolve-types.ts
var import_lodash = __toESM(require("lodash"), 1);
var import_zod2 = require("zod");

// src/get-default-input.ts
var import_zod = require("zod");
var import_zod_to_ts = require("zod-to-ts");
var getProcedureSchemas = (procedures) => {
  const procedureSchemas = { queries: {}, mutations: {} };
  const procedureTypes = { queries: {}, mutations: {} };
  Object.entries(procedures).filter(([, { _def }]) => _def.query || _def.mutation).forEach(([procedureName, procedure]) => {
    const inputParser = getInputFromInputParsers(procedure._def.inputs);
    if (typeof inputParser === "function") {
      return import_zod.z.any();
    }
    const defaultInputValue = inputParser ? getDefaultForDef(inputParser._def) : "";
    let procedureType = "";
    let docsType = "";
    if (inputParser) {
      const { node } = (0, import_zod_to_ts.zodToTs)(inputParser);
      procedureType = `input: ${(0, import_zod_to_ts.printNode)(node)}`;
      docsType = (0, import_zod_to_ts.printNode)((0, import_zod_to_ts.createTypeAlias)(node, "input", inputParser.description));
    }
    const procedureDefaults = {
      inputLength: defaultInputValue.length,
      value: `await trpc.${procedureName}.${procedure._def.query ? "query" : "mutate"}(${defaultInputValue})`
    };
    const procedureObject = procedure._def.query ? procedureSchemas.queries : procedureSchemas.mutations;
    const typeProcedureObject = procedure._def.query ? procedureTypes.queries : procedureTypes.mutations;
    procedureObject[procedureName] = { default: procedureDefaults, type: docsType };
    typeProcedureObject[procedureName] = procedureType;
  });
  return { schemas: procedureSchemas, types: procedureTypes };
};
var getDefaultForDef = (def) => {
  if (!def)
    return "";
  switch (def.typeName) {
    case import_zod.ZodFirstPartyTypeKind.ZodString:
      return defaultString();
    case import_zod.ZodFirstPartyTypeKind.ZodDate:
      return defaultDate();
    case import_zod.ZodFirstPartyTypeKind.ZodNumber:
      return defaultNumber();
    case import_zod.ZodFirstPartyTypeKind.ZodBigInt:
      return defaultBigInt();
    case import_zod.ZodFirstPartyTypeKind.ZodBoolean:
      return defaultBoolean();
    case import_zod.ZodFirstPartyTypeKind.ZodUndefined:
      return defaultUndefined();
    case import_zod.ZodFirstPartyTypeKind.ZodNull:
      return defaultNull();
    case import_zod.ZodFirstPartyTypeKind.ZodObject:
      return defaultObject(def);
    case import_zod.ZodFirstPartyTypeKind.ZodArray:
      return defaultArray(def);
    case import_zod.ZodFirstPartyTypeKind.ZodTuple:
      return defaultTuple(def);
    case import_zod.ZodFirstPartyTypeKind.ZodRecord:
      return defaultRecord(def);
    case import_zod.ZodFirstPartyTypeKind.ZodLiteral:
      return defaultLiteral(def);
    case import_zod.ZodFirstPartyTypeKind.ZodNullable:
      return defaultNullable(def);
    case import_zod.ZodFirstPartyTypeKind.ZodOptional:
      return defaultOptional(def);
    case import_zod.ZodFirstPartyTypeKind.ZodIntersection:
      return defaultIntersection(def);
    case import_zod.ZodFirstPartyTypeKind.ZodEnum:
      return defaultEnum(def);
    case import_zod.ZodFirstPartyTypeKind.ZodNativeEnum:
      return defaultNativeEnum(def);
    case import_zod.ZodFirstPartyTypeKind.ZodMap:
      return defaultMap(def);
    case import_zod.ZodFirstPartyTypeKind.ZodSet:
      return defaultSet(def);
    case import_zod.ZodFirstPartyTypeKind.ZodPromise:
      return defaultPromise(def);
    case import_zod.ZodFirstPartyTypeKind.ZodNaN:
      return "NaN";
    case import_zod.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
    case import_zod.ZodFirstPartyTypeKind.ZodUnion:
      return defaultUnion(def);
    default:
      return "";
  }
};
var defaultString = () => {
  return `""`;
};
var defaultDate = () => {
  return `new Date()`;
};
var defaultNumber = () => {
  return `0`;
};
var defaultBigInt = () => {
  return `BigInt(0)`;
};
var defaultBoolean = () => {
  return `false`;
};
var defaultUndefined = () => {
  return `undefined`;
};
var defaultNull = () => {
  return `null`;
};
var defaultObject = (def) => {
  let ret = `{ `;
  const entries = Object.entries(def.shape());
  entries.forEach(([name, propDef], idx) => {
    ret += `${name}: ${getDefaultForDef(propDef._def)}`;
    if (idx !== entries.length - 1)
      ret += `, `;
    else
      ret += ` `;
  });
  ret += `}`;
  return ret;
};
var defaultArray = (def) => {
  return `[${getDefaultForDef(def.type._def)}]`;
};
var defaultTuple = (def) => {
  let ret = `[`;
  for (let i = 0; i < def.items.length; i++) {
    const item = def.items[i];
    ret += `${getDefaultForDef(item._def)}`;
    if (i !== def.items.length - 1)
      ret += ``;
  }
  return ret;
};
var defaultRecord = (_def) => {
  return `{ ${getDefaultForDef(_def.keyType._def)}: ${getDefaultForDef(_def.valueType._def)} }`;
};
var defaultLiteral = (def) => {
  return typeof def.value === "string" ? `"${def.value}"` : `${def.value}`;
};
var defaultNullable = (def) => {
  return getDefaultForDef(def.innerType._def);
};
var defaultOptional = (def) => {
  return getDefaultForDef(def.innerType._def) ?? `undefined`;
};
var defaultEnum = (def) => {
  return `"${def.values[0]}"`;
};
var defaultUnion = (def) => {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.length === 0)
    return "";
  return getDefaultForDef(options[0]._def);
};
var defaultIntersection = (def) => {
  return getDefaultForDef(def.right._def);
};
var defaultNativeEnum = (def) => {
  const val = Object.values(def.values)[Object.values(def.values).length - 1];
  if (val) {
    return typeof val === "string" ? `"${val}"` : `${val}`;
  }
  return "";
};
var defaultMap = (_def) => {
  return `new Map([[${getDefaultForDef(_def.keyType._def)}, ${getDefaultForDef(_def.valueType._def)}]])`;
};
var defaultSet = (_def) => {
  return `new Set([${getDefaultForDef(_def.valueType._def)}])`;
};
var defaultPromise = (def) => {
  return `Promise.resolve(${getDefaultForDef(def.type._def)})`;
};

// src/zod-resolve-types.ts
var buildTrpcTsType = (router, procedureTypes) => {
  const procedures = router._def.procedures;
  const procedureObject = {};
  Object.entries(procedures).filter(([, { _def }]) => _def.query || _def.mutation).forEach(([name, procedure]) => {
    let procedureTypeDef = "";
    const inputType = procedureTypes.mutations[name] || procedureTypes.queries[name] || "";
    if (procedure._def?.query)
      procedureTypeDef += `query: (${inputType}) => void,`;
    else if (procedure._def?.mutation)
      procedureTypeDef += `mutate: (${inputType}) => void,`;
    import_lodash.default.set(procedureObject, name, `{${procedureTypeDef}}`);
  });
  const buildNestedTrpcObject = (obj) => {
    return Object.entries(obj).map(([name, value]) => {
      if (typeof value === "string")
        return `'${name}': ${value}`;
      return `'${name}': {${buildNestedTrpcObject(value)}}`;
    }).join(",");
  };
  return `type Trpc = {${buildNestedTrpcObject(procedureObject)}}
declare var trpc: Trpc;`;
};
var zodResolveTypes = async (router) => {
  const { schemas, types } = getProcedureSchemas(router._def.procedures);
  return {
    tsTypes: buildTrpcTsType(router, types),
    ...schemas
  };
};
var getInputFromInputParsers = (inputs) => {
  if (inputs.length === 0)
    return null;
  if (inputs.length === 1)
    return inputs[0];
  const mergedObj = inputs.reduce((mergedObj2, inputParser) => {
    return mergedObj2.merge(inputParser);
  }, import_zod2.z.object({}));
  return mergedObj;
};

// html-version:./html-version
var version = "1.0.4";

// src/config.ts
var defineConfig = (config) => config;
var getDefaultConfig = () => defineConfig({
  resolveTypes: zodResolveTypes,
  polling: {
    enable: true,
    interval: 4e3
  },
  renderOptions: {
    cdnUrl: "//cdn.jsdelivr.net/npm",
    version
  },
  request: {
    globalHeaders: {},
    superjson: false
  },
  server: {
    serveHtml: true
  }
});
var resolveConfig = (config) => {
  const resolvedConfig = import_lodash2.default.merge({}, getDefaultConfig(), config);
  const resolvedVersion = config?.renderOptions?.version === null ? null : resolvedConfig.renderOptions.version;
  return {
    ...resolvedConfig,
    renderOptions: {
      ...resolvedConfig.renderOptions,
      version: resolvedVersion
    }
  };
};

// src/handler.ts
var handler = (0, import_uttp.defineHandler)(async (helpers, config) => {
  const resolvedConfig = resolveConfig(config);
  let htmlPlaygroundPage = void 0;
  if (resolvedConfig.server?.serveHtml) {
    htmlPlaygroundPage = (0, import_html.renderPlaygroundPage)({
      ...resolvedConfig.renderOptions,
      clientConfig: resolvedConfig
    });
  }
  const types = await resolvedConfig.resolveTypes(config.router);
  const stringifiedTypes = JSON.stringify(types);
  return {
    async handleRequest(request) {
      if (request.method === "HEAD") {
        return {
          status: 204,
          body: void 0
        };
      }
      if (request.method === "GET" && resolvedConfig.server.serveHtml) {
        return {
          status: 200,
          headers: {
            "Content-Type": "text/html"
          },
          body: htmlPlaygroundPage
        };
      }
      if (request.method === "POST") {
        let body;
        const rawBody = request.rawRequest.body;
        if (typeof rawBody === "object" && rawBody !== null && "operation" in rawBody) {
          body = rawBody;
        } else {
          try {
            body = await helpers.parseBodyAsString(request.rawRequest);
          } catch {
            return { status: 413, body: void 0 };
          }
        }
        const bodyObject = typeof body === "string" ? JSON.parse(body) : body;
        if (bodyObject.operation === "getRouterSchema") {
          return {
            headers: {
              "Content-Type": "application/json"
            },
            status: 200,
            body: stringifiedTypes
          };
        }
        return { status: 400, body: void 0 };
      }
      return { status: 400, body: void 0 };
    },
    adapterOptions: { maxBodySize: resolvedConfig.server.maxBodySize }
  };
});

// src/handlers/fastify.ts
var getFastifyPlugin = (0, import_fastify.getFastifyAdapter)(
  handler
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getFastifyPlugin
});
